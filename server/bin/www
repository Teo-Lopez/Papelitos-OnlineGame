#!/usr/bin/env node

const http = require("http");

let app = require("../app");

// catch 404 and render a not-found.hbs template
app.use((req, res, next) => {
  res.status(404);
  res.render("not-found");
});

app.use((err, req, res, next) => {
  // always log the error
  console.error("ERROR", req.method, req.path, err);

  // only render if the error ocurred before sending the response
  if (!res.headersSent) {
    res.status(500);
    res.render("error");
  }
});

let server = http.createServer(app);

//IMPORTANT PART
const socketIo = require("socket.io");
const io = socketIo(server); // < Interesting!
const allGames = [];
io.on("connection", (socket) => {
  console.log("New client connected");
  socket.on("getList", () => {
    console.log("sending first list");
    socket.emit(
      "matchList",
      allGames.map((game) => game.name)
    );
  });

  socket.on("newMatch", (data) => {
    const name = data.matchId;
    const newUser = data.user;
    const existGame = (name) => allGames.some((game) => game.name == name);
    const isUserInGame = (name, newUser) => {
      const idx = allGames.findIndex((game) => game.name === name);

      return allGames[idx].users.some((user) => user.name === newUser);
    };

    const example = {
      name,
      turn: 0,
      users: [{ name: newUser, id: socket.id }],
      activeWord: "",
      words: [],
      activePlayer: "",
      rooster: [],
    };

    if (!existGame(name))
      allGames.push({ name, turn: 0, users: [{ name: newUser, id: socket.id }], activeWord: "", words: [], activePlayer: "", rooster: [] });
    else if (!isUserInGame(name, newUser)) {
      const gameIdx = allGames.findIndex((game) => game.name === name);
      allGames[gameIdx].users.push({ name: newUser, id: socket.id });
      allGames[gameIdx].rooster.push({ name: newUser, id: socket.id });
    }
    console.log("New list of matches: \b ", allGames, " \b---------------");
    socket.emit(
      "matchList",
      allGames.map((game) => game.name)
    );
    socket.broadcast.emit(
      "matchList",
      allGames.map((game) => game.name)
    );
    socket.join(name);
  });

  socket.on("updateGame", (game) => {
    const idx = allGames.find((elm) => elm.name == game.name);
    allGames.splice(idx, 1, game);
    console.log(allGames, "ACTUALIZADO MADERFAKER");
  });

  //Cada vez que el front requiere actualizar el objeto game.
  socket.on("getActiveGame", (roomName) => {
    console.log("sending game");
    console.log(roomName);
    io.sockets.in(roomName).emit(
      "activeGame",
      allGames.find((elm) => elm.name === roomName)
    );
    // io.sockets.in(roomName).emit(
    //   "activeGame",
    //   allGames.find((elm) => elm.name === roomName)
    // );
  });

  socket.on("postWord", ({ matchId, newWord }) => {
    console.log(newWord);
    const idx = allGames.findIndex((game) => game.name == matchId);
    allGames[idx].words.push(newWord);
    io.sockets.in(matchId).emit("activeGame", allGames[idx]);
  });
  //STUFF TO DO ON CONNECTION
  socket.on("disconnect", () => console.log("Client disconnected"));
});

/////////////////

server.on("error", (error) => {
  if (error.syscall !== "listen") {
    throw error;
  }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case "EACCES":
      console.error(`Port ${process.env.PORT} requires elevated privileges`);
      process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(`Port ${process.env.PORT} is already in use`);
      process.exit(1);
      break;
    default:
      throw error;
  }
});

server.listen(process.env.PORT, () => {
  console.log(`Listening on http://localhost:${process.env.PORT}`);
});
